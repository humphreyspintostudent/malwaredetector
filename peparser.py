#!/usr/bin/python3.8

import pefile
import os
import sys

class PEParser:

    def __init__(self, fpath):
        self.fpath = fpath
        self.pe = pefile.PE(fpath)

    @classmethod
    def is_pefile(cls, filename):
        fd = open(filename, 'rb')
        mg_hd = fd.read(2)

        if mg_hd == b'MZ':
            return True

        return False

    def parse_pe_version_info(self):
        """Return version infos"""
        #ISSUE: returns empty with new pefile versions
        res = {}
        if hasattr(self.pe, 'FileInfo'):
            for fileinfo in self.pe.FileInfo:
                if fileinfo.Key == 'StringFileInfo':
                    for st in fileinfo.StringTable:
                        for entry in st.entries.items():
                            res[entry[0]] = entry[1]
                if fileinfo.Key == 'VarFileInfo':
                    for var in fileinfo.Var:
                        res[var.entry.items()[0][0]] = var.entry.items()[0][1]
        if hasattr(self.pe, 'VS_FIXEDFILEINFO'):
            res['flags'] = self.pe.VS_FIXEDFILEINFO.FileFlags
            res['os'] = self.pe.VS_FIXEDFILEINFO.FileOS
            res['type'] = self.pe.VS_FIXEDFILEINFO.FileType
            res['file_version'] = self.pe.VS_FIXEDFILEINFO.FileVersionLS
            res['product_version'] = self.pe.VS_FIXEDFILEINFO.ProductVersionLS
            res['signature'] = self.pe.VS_FIXEDFILEINFO.Signature
            res['struct_version'] = self.pe.VS_FIXEDFILEINFO.StrucVersion
        return res
    
    def parse_pe_resources(self):
        """Extract resources :
        [entropy, size]"""
        resources = []
        if hasattr(self.pe, 'DIRECTORY_ENTRY_RESOURCE'):
            try:
                for resource_type in self.pe.DIRECTORY_ENTRY_RESOURCE.entries:
                    if hasattr(resource_type, 'directory'):
                        for resource_id in resource_type.directory.entries:
                            if hasattr(resource_id, 'directory'):
                                for resource_lang in resource_id.directory.entries:
                                    data = self.pe.get_data(resource_lang.data.struct.OffsetToData,
                                                        resource_lang.data.struct.Size)
                                    size = resource_lang.data.struct.Size
                                    entropy = get_entropy(data)

                                    resources.append([entropy, size])
            except Exception as e:
                return resources
        return resources

    def parse_pe_header(self):
        res = {}
        
        res['Machine'] = self.pe.FILE_HEADER.Machine
        res['SizeOfOptionalHeader'] = self.pe.FILE_HEADER.SizeOfOptionalHeader
        res['Characteristics'] = self.pe.FILE_HEADER.Characteristics
        res['MajorLinkerVersion'] = self.pe.OPTIONAL_HEADER.MajorLinkerVersion
        res['MinorLinkerVersion'] = self.pe.OPTIONAL_HEADER.MinorLinkerVersion
        res['SizeOfCode'] = self.pe.OPTIONAL_HEADER.SizeOfCode
        res['SizeOfInitializedData'] = self.pe.OPTIONAL_HEADER.SizeOfInitializedData
        res['SizeOfUninitializedData'] = self.pe.OPTIONAL_HEADER.SizeOfUninitializedData
        res['AddressOfEntryPoint'] = self.pe.OPTIONAL_HEADER.AddressOfEntryPoint
        res['BaseOfCode'] = self.pe.OPTIONAL_HEADER.BaseOfCode

        try:
            res['BaseOfData'] = self.pe.OPTIONAL_HEADER.BaseOfData
        except AttributeError:
            res['BaseOfData'] = 0x00

        res['ImageBase'] = self.pe.OPTIONAL_HEADER.ImageBase

        res['SectionAlignment'] = self.pe.OPTIONAL_HEADER.SectionAlignment
        res['FileAlignment'] = self.pe.OPTIONAL_HEADER.FileAlignment
        res['MajorOperatingSystemVersion'] = self.pe.OPTIONAL_HEADER.MajorOperatingSystemVersion
        res['MinorOperatingSystemVersion'] = self.pe.OPTIONAL_HEADER.MinorOperatingSystemVersion
        res['MajorImageVersion'] = self.pe.OPTIONAL_HEADER.MajorImageVersion
        res['MinorImageVersion'] = self.pe.OPTIONAL_HEADER.MinorImageVersion
        res['MajorSubsystemVersion'] = self.pe.OPTIONAL_HEADER.MajorSubsystemVersion
        res['MinorSubsystemVersion'] = self.pe.OPTIONAL_HEADER.MinorSubsystemVersion
        res['SizeOfImage'] = self.pe.OPTIONAL_HEADER.SizeOfImage
        res['SizeOfHeaders'] = self.pe.OPTIONAL_HEADER.SizeOfHeaders
        res['CheckSum'] = self.pe.OPTIONAL_HEADER.CheckSum
        res['Subsystem'] = self.pe.OPTIONAL_HEADER.Subsystem
        res['DllCharacteristics'] = self.pe.OPTIONAL_HEADER.DllCharacteristics
        res['SizeOfStackReserve'] = self.pe.OPTIONAL_HEADER.SizeOfStackReserve
        res['SizeOfStackCommit'] = self.pe.OPTIONAL_HEADER.SizeOfStackCommit
        res['SizeOfHeapReserve'] = self.pe.OPTIONAL_HEADER.SizeOfHeapReserve
        res['SizeOfHeapCommit'] = self.pe.OPTIONAL_HEADER.SizeOfHeapCommit
        res['LoaderFlags'] = self.pe.OPTIONAL_HEADER.LoaderFlags
        res['NumberOfRvaAndSizes'] = self.pe.OPTIONAL_HEADER.NumberOfRvaAndSizes

        # Sections
        res['SectionsNb'] = len(self.pe.sections)
        entropy = map(lambda x: x.get_entropy(), self.pe.sections)
        entropy = list(entropy)

        res['SectionsMeanEntropy'] = sum(entropy) / float(len(entropy))
        res['SectionsMinEntropy'] = min(entropy)
        res['SectionsMaxEntropy'] = max(entropy)
        raw_sizes = map(lambda x: x.SizeOfRawData, self.pe.sections)
        raw_sizes = list(raw_sizes)

        res['SectionsMeanRawsize'] = sum(raw_sizes) / float(len(raw_sizes))
        res['SectionsMinRawsize'] = min(raw_sizes)
        res['SectionsMaxRawsize'] = max(raw_sizes)
        virtual_sizes = map(lambda x: x.Misc_VirtualSize, self.pe.sections)
        virtual_sizes = list(virtual_sizes)

        res['SectionsMeanVirtualsize'] = sum(virtual_sizes) / float(len(virtual_sizes))
        res['SectionsMinVirtualsize'] = min(virtual_sizes)
        res['SectionMaxVirtualsize'] = max(virtual_sizes)

        # Imports
        try:
            res['ImportsNbDLL'] = len(self.pe.DIRECTORY_ENTRY_IMPORT)
            imports = sum([x.imports for x in self.pe.DIRECTORY_ENTRY_IMPORT], [])
            res['ImportsNb'] = len(imports)
            res['ImportsNbOrdinal'] = len(list(filter(lambda x: x.name is None, imports)))
        except AttributeError:
            res['ImportsNbDLL'] = 0
            res['ImportsNb'] = 0
            res['ImportsNbOrdinal'] = 0

        # Exports
        try:
            res['ExportNb'] = len(self.pe.DIRECTORY_ENTRY_EXPORT.symbols)
        except AttributeError:
            # No export
            res['ExportNb'] = 0
        # Resources
        resources = self.parse_pe_resources()
        res['ResourcesNb'] = len(resources)
        if len(resources) > 0:
            entropy = map(lambda x: x[0], resources)
            res['ResourcesMeanEntropy'] = sum(entropy) / float(len(entropy))
            res['ResourcesMinEntropy'] = min(entropy)
            res['ResourcesMaxEntropy'] = max(entropy)
            sizes = map(lambda x: x[1], resources)
            res['ResourcesMeanSize'] = sum(sizes) / float(len(sizes))
            res['ResourcesMinSize'] = min(sizes)
            res['ResourcesMaxSize'] = max(sizes)
        else:
            res['ResourcesNb'] = 0
            res['ResourcesMeanEntropy'] = 0
            res['ResourcesMinEntropy'] = 0
            res['ResourcesMaxEntropy'] = 0
            res['ResourcesMeanSize'] = 0
            res['ResourcesMinSize'] = 0
            res['ResourcesMaxSize'] = 0

        # Load configuration size
        try:
            res['LoadConfigurationSize'] = self.pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.Size
        except AttributeError:
            res['LoadConfigurationSize'] = 0

        # Version configuration size
        try:
            version_infos = self.parse_pe_version_info()
            res['VersionInformationSize'] = len(version_infos.keys())
        except AttributeError:
            res['VersionInformationSize'] = 0
        return res